\newpage

APPENDICE AU CHAPITRE 1.

\section{Récréation informatique.}




Nous choisissons dans ces récréations de présenter les algorithmes étudiés précédemment sous la forme de programme Python (ou Sage). Il sera possible de télécharger ces programmes sur le site 
\begin{center}
\url{https://github.com/RichardGanaye}
\end{center}
\subsection{Quelques procédures arithmétique générales.}

Donnons d'abord le module ``numtheory'' présentant les procédures usuelles de théorie des nombres.

La fonction {\bf isprime} est un test de primalité probaliliste, avec une certaine probabilité d'erreur.

La fonction {\bf ifactors} est naïve. Elle ne peut fonctionner que pour des petits nombres. Il sera préférable de la remplacer par l'ordre {\bf factor} de Sage pour les grands nombres.

\begin{verbatim}
"""
    Created on Sat Aug 31 19:21:15 2013
    @author: Richard Ganaye
"""

from random import randint

def powermod(a,n,p):
    """retourne a^n mod p (exponentiation rapide )
       resultat positif
    """
    resu=1
    while n!= 0:
        if n%2 != 0:
            resu = (a*resu) % p
        a = (a*a) % p
        n=n//2
    return resu
    
def expomod(a,n,p):
    """retourne a^n mod p (exponentiation rapide )
       resultat entre -p/2 et p/2
    """
    resu=1
    while n!= 0:
        if n%2 != 0:
            resu = (a*resu) % p
        a = (a*a) % p
        n=n//2
    if resu>p//2:
        resu -=p
    return resu

def legendre(a,p):
    """retourne le symbole de Legendre (a/p) si p premier"""
    return expomod(a,(p-1)//2,p)

def jacobi2(n):
    """retourne jacobi(n,2)"""
    r = n%8
    if r==1 or r==7:
        return 1
    else:
        return -1

def jacobi(n,m):
    """retourne le symbole de Jacobi (n/m)"""
    if n==0: return 0
    prod = 1
    while m>1:
        k = 0
        while n%2 == 0:
            k += 1
            n = n//2
        if k%2 == 1:
            prod = prod*jacobi2(m)
        if (n%4 == 3 and m%4 == 3):
            prod = -prod
        num = m%n
        m = n
        n = num
    return prod

def pgcd(a,b):
    a , b = abs(a), abs(b)
    while b != 0:
        a, b = b, a%b
    return a


def isprime(p,k=30):
    """ test de primalite, proba d'erreur < 2^(-k)"""
    if p <= 1: return False
    if p <= 3: return True
    test = True
    while k>0:
        k-=1
        b = randint(2,p-2)
        if pgcd(b,p) !=1:
            test = False
        else:
            if legendre(b,p) != jacobi(b,p):
                test = False
    return test

def nextprime(n):
    q=n+1
    while not isprime(q):
        q += 1
    return q

def plusPetitFacteur(n):
    """ plus petit facteur premier si n>1"""
    if n==1 or isprime(n):
        return n
    else:
        d = 2
        while n%d != 0:
            d += 1
        return d

def ifactors(n):
    """decomposition en facteurs d'un entier n>1"""
    l=[]
    while n!=1:
        p=plusPetitFacteur(n)
        alpha = 0
        while n%p == 0:
            n //=p
            alpha += 1
        l.append([p,alpha])
    return l

def factorielle(n):
    fact = 1
    while n>1:
        fact *= n
        n -= 1
    return fact


def lucas(p):
    """ retourne True ssi 2**p-1 est premier """
    def S(n,p):
        Mp=2**p-1
        s=4
        i=1
        while i<n:
            s=(s*s - 2) % Mp
            i+=1
        return s

    if S(p-1,p) == 0:
        return True
    else:
        return False


def bezout(a,b):
    """input  : couple d'entiers (a,b)
        output : triplet (x,y,d),
        (x,y) solution de ax+by =d, d = pgcd(a,b)
    """
    sgn_a = 1 if a >= 0 else -1
    sgn_b = 1 if b >= 0 else -1
    (r0, r1)=(abs(a), abs(b))
    (u0, v0) = (1, 0)
    (u1, v1) = (0, 1)
    while r1 != 0:
        q = r0 // r1
        (r2, u2, v2) = (r0 - q * r1, u0 - q * u1, v0 - q * v1)
        (r0, r1) = (r1, r2)
        (u0, u1) = (u1, u2)
        (v0, v1) = (v1, v2)
    x , y, d  = sgn_a * u0, sgn_b * v0, r0
    if x <= 0: x, y = x + abs(b), y - sgn_b * a
    return x, y, d

def inverse(a,modulo):
    """retourne l'inverse de a mod modulo
    """
    return bezout(a,modulo)[0] % modulo

def racineEntiere(n):
    """input  : entier n positif ou nul
        output : partie entière de la racine de n
    """
    a=n
    b=(n+1)//2
    while b<a:
        a=b
        b=(a*a+n)//(2*a)
    return a

def carre(A):
    """ input : entier naturel A
        output: True ssi A est un carré
    """
    a=racineEntiere(A)
    if a*a==A:
        return True
    else:
        return False

def convert(n,base=10):
    l=[]
    while n!=0:
        r=n%base
        l.append(r)
        n = n//base
    return l

def primroot(p):
    assert(isprime(p))
    pas_trouve = True
    g = 1
    while pas_trouve:
        g += 1
        l = ifactors(p-1)
        k = 0
        test = True
        while k<len(l) and test:
            q = l[k][0]
            if expomod(g,(p-1)//q, p) == 1:
                test = False
            k += 1
        if test: pas_trouve = False
    return g
        
def chinois(a1,a2,n1,n2):
    "retourne x tel que x=a1[n1], x=a2[n2]"
    t = bezout(n1,n2)
    (u,v)=(t[0],t[1])
    r = (n2*v*a1 + n1*u*a2) % (n1*n2)
    return (n2*v*a1 + n1*u*a2) % (n1*n2)
    
def chinoiserie(liste,modules):
    "reste chinois pour des listes"
    liste = liste[:]
    modulos = modules[:]
    lg = len(liste)
    if lg==1:
        return liste[0] % modulos[0]
    else:
        a2 = liste.pop(0)
        n2 = modulos.pop(0)
        prod=1
        for nombre in modulos:
            prod *= nombre
        z = chinoiserie(liste,modulos)
        return chinois(z,a2,prod,n2)
    
if __name__ == '__main__':
    print(inverse(217,11213))
    
\end{verbatim}
\subsection{Méthode d'Euler.}
Mettons d'abord en oeuvre l'algorithme correspondant à la descente d'Euler proposé au la section \ref{section1_4} ``Sommes de deux carrés : la méthode d'Euler''. Ce n'est pas la plus efficace puisqu'elle nécessite une factorisation.

\begin{verbatim}
from numtheory import jacobi, carre, isprime, ifactors, nextprime
from random import randint

def reste_minimal(a,b):
    assert(b > 0)
    r = a % b
    if 2 * r > b:
        r -= b
    return r
    
def racine_de_moins_un(p):
    """ 
    input : p premier congru à 1 modulo 4
    output :  k tel que k^2 = -1 mod p
    |k| minimal, k > 0
    """
    assert isprime(p), "p non premier"
    assert p % 4 == 1, "p premier non congru à 1 modulo 4"
    while True:
        a = randint(2, p - 2)
        if jacobi(a, p) == -1:
            break
    b = pow(a, (p - 1) // 4, p)
    k = reste_minimal(b, p)
    return abs(k)   

def decomposition(p):
    if p == 2: 
        return (1,1)
    k = racine_de_moins_un(p)
    u = (k**2 + 1) // p
    l = ifactors(u)
    li = []
    for p,alpha in l:
        for i in range(alpha):
            li.append(p)
    if li == []:
        return (k,1)
    a, b = k, 1 
    for q in li:
        c,d = decomposition(q)
        if (a*c + b*d) % q == 0:
            a, b = (a*c + b*d) // q, (b*c - a*d) // q
        else: # (a*c - b*d) % q == 0
            a, b = (a*c - b*d) // q, (b*c + a*d) // q
    return (abs(a),abs(b))
        
        
if __name__ == "__main__":
    ttest = [13, 101, 10009, 11213,  100049, 1000000009,
             1234567891234567891234567909, 10**50 + 577]
    for p in ttest:
        a,b = decomposition(p)
        assert p == a**2 + b**2, "erreur test"
        print(p,'=>', a, b)
\end{verbatim}

Notons que si on ajoute aux tests le nombre premier $10**100 + 949$, le programme ne donne pas de réponse dans des délais raisonnables, ce qui ne sera pas le cas pour les procédures suivantes.

\subsection{Calcul du pgcd dans $\Z[i]$.}

Donnons d'abord le module {\bf Zi} qui construit la classe des entiers de Gauss.
\begin{verbatim}
class Zi:
    """ classe Zi des entiers de Gauss a + ib"""
    
    def __init__(self,a = 0,b = 0):
        self.re = int(a)
        self.im = int(b)
        
    def Re(self):
        return self.re
        
    def Im(self):
        return self.im
        
    def couple(self):
        return [self.re, self.im]
        
    def norme(self):
        return (self.re)**2+(self.im)**2
        
    def bar(self):
        return Zi(self.re, -self.im) 
        
    def div(self, n):
        return Zi(self.re // n, self.im // n)
             
    def __repr__(self):
        if self.im>0:
            return f"{self.re} + {self.im} i"
        if self.im<0:
            return f"{self.re} - {abs(self.im)} i"
        if self.im == 0:
            return f"{self.re}"
        
    def __eq__(self, other):
        if isinstance(other,int):
            return self.im == 0 and self.re == other
        return self.re == other.re and self.im == other.im
    
    def __hash__(self):
        return (11 * self.re + self.im) // 16
        
    def __add__(self,other):
        if isinstance(other,int): return Zi(self.re + other,self.im)
        return Zi(self.re + other.re, self.im + other.im)

    def __sub__(self,other):
        if isinstance(other,int): return Zi(self.re - other,self.im)
        return Zi(self.re - other.re, self.im - other.im)

    def __mul__(self,other):
        if isinstance(other,int): return Zi(self.re * other,self.im * other)
        return Zi(self.re * other.re - self.im * other.im,
            self.re * other.im + self.im * other.re)
            
    def __floordiv__(self, other):
        a = self.re; b = self.im
        c = other.re; d = other.im
        return Zi((2*(a*c+b*d) +c*c+d*d) // (2*(c*c + d*d)),
            (2*(b*c-a*d) + c*c + d*d) // (2*(c*c+d*d)))
        
    def __mod__(self, other):
        return self - ( self // other) * other
        
    def __rmul__(self, a):
        return Zi(a * self.re, a* self.im)
    
    def __radd__(self, other):
        return Zi(other + self.re, self.im)
        
    def __rsub__(self,other):
        return Zi(other - self.re, -self.im)
        
    def __neg__(self):
        return Zi(-self.re, -self.im)
        
    def __pos__(self):
        return self
        
    def __pow__(self,n):
        resu = Zi(1)
        a = self
        while n!= 0:
            if n % 2 != 0:
                resu = resu * a
            a = a * a
            n = n // 2
        return resu
 
i = Zi(0,1)

if __name__ == "__main__":
    z = Zi(31,7)
    t = Zi(3,5)
    print(z,t)
    print(z//t, z % t)

\end{verbatim}

Le programme suivant permet la décomposition d'un nombre premier de la forme $4k+1$ en somme de deux carrés, à la vitesse de l'algorithme d'Euclide. Il suit l'algoritme présenté dans le paragraphe \ref{section1_2} ``Somme de deux carrés : une première preuve.''.

\begin{verbatim}
from random import randint
from numtheory import isprime
from Zi import *

def pgcd(a,b):
    while b != Zi(0, 0):
        a, b = b, a % b
    return a

def racine_de_moins_un(p):
    pas_trouve = True
    while pas_trouve:
        a = randint(2, p - 2)
        b = pow(a, (p - 1)//4, p)
        if (b * b) % p == p-1:
            pas_trouve = False
    if 2 * b > p:
        b = b - p
    return b

def decomposition_carres(p):
    assert(p % 4 == 1)
    assert(isprime(p))
    a = racine_de_moins_un(p)
    pr = Zi(p)
    z = pgcd(pr, a+i)
    return abs(z.Re()), abs(z.Im())

if __name__ == "__main__":
    ttest = [13, 101, 10009, 11213,  100049, 1000000009,
             1234567891234567891234567909, 10**50 + 577, 10**100 + 949]
    for p in ttest:
        a,b = decomposition_carres(p)
        assert p == a**2 + b**2, "erreur test"
        print(p,'=>', a, b)
\end{verbatim}

Notons qu'il donne une réponse immédiate, même pour le nombre premier $10^{100}+949$, sur lequel buttait le programme précédent.

\subsection{L'algorithme de Lehmmann.}
Il correspond à l'algorithme présenté à la section \ref{section1_5} ``Autre preuve et algorithme pour la décomposition en somme de deux carrés'', donné dans [Lehmann] ``Quadratic numbers''.
\begin{verbatim}
"""algorithme de Lehman, quadratic numbers"""

from numtheory import jacobi, carre, isprime
from random import randint
from Zn import Mod

def reste_minimal(a,b):
    assert(b > 0)
    r = a % b
    if 2 * r > b:
        r -= b
    return r

def racine_de_moins_un(p):
    """ 
    input : p premier congru à 1 modulo 4
    output :  k tel que k^2 = -1 mod p
    |k| minimal, k > 0
    """
    assert isprime(p), "p non premier"
    assert p % 4 == 1, "p premier non congru à 1 modulo 4"
    while True:
        a = randint(2, p - 2)
        if jacobi(a, p) == -1:
            break
    b = pow(a, (p - 1) // 4, p)
    k = reste_minimal(b, p)
    return abs(k)   
    
def somme_carres(p):
    k = racine_de_moins_un(p)
    a = (k**2 + 1) // p
    q, r = k, 1
    while a != 1:
        m, n = reste_minimal(q, a), reste_minimal(r, a)
        b = (m**2 + n**2) // a
        q, r = (q * m + r * n) // a, (q *n - r * m) // a
        a = b
    return abs(q),abs(r)
        

if __name__ == "__main__":
    ttest = [13, 101, 10009, 11213,  100049, 1000000009,
             1234567891234567891234567909, 10**50 + 577, 10**100 + 949]
    for p in ttest:
        a,b = somme_carres(p)
        assert p == a**2 + b**2, "erreur test"
        print(p,'=>', a, b)
\end{verbatim}

Il donne lui aussi des réponses immédiates.

Un autre algorithme de décomposition en sommes de deux carrés, très différent, sera présenté dans le chapitre ``Formes quadratiques''.